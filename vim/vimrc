" ------------------------------------------------------------------------------
" # Defaults
" ------------------------------------------------------------------------------

" Vim 8 defaults
" For more info, see :help defaults.vim
unlet! skip_defaults_vim
silent! source $VIMRUNTIME/defaults.vim


" ------------------------------------------------------------------------------
" # Sourcing
" ------------------------------------------------------------------------------

" Get path relative to vimrc
function! s:VimrcPath(path)
  return '~/.dotfiles/vim/' . a:path
endfunction

" Source plugins
call plug#begin('~/.vim/plugged')
  execute 'source ' . s:VimrcPath('plugins.vim')
call plug#end()

" Can this be included via vim-plug?
packadd! matchit

" Source mappings
execute 'source ' s:VimrcPath('mappings.vim')

" Setup dynamic sourcing
function! s:SourceConfigFilesIn(folder)
  for config_file in split(glob(s:VimrcPath(a:folder . '/*')), '\n')
    if filereadable(config_file)
      execute 'source' config_file
    endif
  endfor
endfunction

" Dynamic sourcing
call s:SourceConfigFilesIn('plugins')


" ------------------------------------------------------------------------------
" # Settings
" ------------------------------------------------------------------------------

set hidden
set nobackup
set noswapfile
set autoread
set confirm
set encoding=utf-8
set clipboard=unnamed
set backspace=indent,eol,start
set relativenumber
set noshowmode
" set lazyredraw                               " Had this for some reason, but it causes deoplete flicker
set updatetime=1000                            " Set updatetime for CursorHold, gitgutter, etc.
set fillchars+=vert:\ ,                        " Vertical split character
call matchadd('ColorColumn', '\%121v', 100)    " Only show 121st character on lines that might exceed 120
set completeopt=menu,menuone,noinsert,noselect " Auto complete menu options

" Always insert completion popup candidate without entering new line.
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"

let g:airline_theme='base16color'

let g:NERDTreeWinSize=45
let g:NERDTreeQuitOnOpen = 1

let g:peekaboo_window = 'vertical botright 60new'

let g:pdv_template_dir = $HOME . "/.vim/plugged/pdv/templates_snip"

let g:ale_sign_error = '!'
let g:ale_sign_style_error = '!'
let g:ale_sign_warning = '!'
let g:ale_sign_style_warning = '!'

let g:ale_linters = {
  \ 'php': ['php', 'phpcs', 'phpmd'],
  \ }

let g:ale_php_phpcs_standard = 'PSR2'

let g:deoplete#enable_at_startup = 1
call deoplete#custom#source('_', 'max_menu_width', 120)
call deoplete#custom#option('auto_complete_delay', 600)

let g:phpactorBranch = 'develop'

let g:vdebug_options= {
  \ "port" : 9001,
  \ }

let test#php#patterns = {
  \ 'test':      ['\v^\s*function (\w*)\(', '\v^\s*public function (\w*)\('],
  \ 'namespace': [] }

let g:vim_markdown_frontmatter = 1

let g:targets_seekRanges = 'cc cr cb cB lc ac Ac lr lb ar ab lB Ar aB Ab AB'

let g:writable_search_new_buffer_command = 'enew'


" ------------------------------------------------------------------------------
" # Theming
" ------------------------------------------------------------------------------

"let base16colorspace=256
colorscheme base16-monokai
set hlsearch
highlight Normal ctermbg=none
highlight NonText ctermbg=none
highlight Search ctermbg=blue ctermfg=white
highlight Visual ctermbg=black ctermfg=white
highlight LineNr ctermbg=none
highlight CursorLineNR ctermbg=green ctermfg=green
highlight SignColumn ctermbg=none
highlight ColorColumn ctermbg=black
highlight GitGutterAdd ctermbg=none ctermfg=green
highlight GitGutterChange ctermbg=none ctermfg=yellow
highlight GitGutterDelete ctermbg=none ctermfg=red
highlight GitGutterChangeDelete ctermbg=none ctermfg=red
highlight VertSplit ctermbg=none ctermfg=none
highlight StatusLine ctermfg=none ctermbg=none
highlight StatusLineNC ctermfg=none ctermbg=none
highlight CursorLine ctermbg=black ctermfg=none
highlight QuickFixLine ctermbg=black ctermfg=none
highlight ALEErrorSign ctermbg=none ctermfg=red
highlight ALEWarningSign ctermbg=none ctermfg=magenta
highlight Pmenu ctermfg=grey ctermbg=black
highlight PmenuSel ctermfg=white ctermbg=blue
highlight PmenuSbar ctermbg=black
highlight PmenuThumb ctermbg=white


" ------------------------------------------------------------------------------
" # Functions
" ------------------------------------------------------------------------------

function! HelpImprovements()
  wincmd o
  nnoremap <buffer> <CR> <C-]>
  nnoremap <buffer> <Esc> <C-t>
endfunction

function! PlaybackMacroOverVisualRange()
  echo "@".getcmdline()
  execute ":'<,'>normal @".nr2char(getchar())
endfunction


" ------------------------------------------------------------------------------
" # Commands
" ------------------------------------------------------------------------------

" [crickets]


" ------------------------------------------------------------------------------
" # Auto Commands
" ------------------------------------------------------------------------------

augroup misc_commands
  autocmd!
  autocmd BufWinEnter * if &l:buftype ==# 'help' | call HelpImprovements() | endif
  autocmd FocusGained,BufEnter,CursorHold,CursorHoldI * checktime
  autocmd BufEnter * EnableStripWhitespaceOnSave
  autocmd BufReadPost quickfix nested nmap <buffer> <CR> <CR>
  autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
augroup END

augroup filetype_settings
  autocmd!
  autocmd FileType zsh setlocal ts=2 sw=2 sts=2 expandtab
  autocmd FileType vim setlocal ts=2 sw=2 sts=2 expandtab
  autocmd FileType php setlocal ts=4 sw=4 sts=4 expandtab commentstring=//\ %s omnifunc=phpactor#Complete
  autocmd FileType html setlocal ts=4 sw=4 sts=4 expandtab
  autocmd FileType css setlocal ts=4 sw=4 sts=4 expandtab
  autocmd FileType scss setlocal ts=4 sw=4 sts=4 expandtab
  autocmd FileType less setlocal ts=2 sw=2 sts=2 expandtab
  autocmd FileType javascript setlocal ts=4 sw=4 sts=4 expandtab
  autocmd FileType vue setlocal ts=4 sw=4 sts=4 expandtab commentstring=//\ %s
  autocmd FileType vue syntax sync fromstart
  autocmd FileType snippets setlocal ts=4 sw=4 sts=4 expandtab
augroup END


" ------------------------------------------------------------------------------
" # Vimrc Local
" ------------------------------------------------------------------------------

augroup vimrc
  autocmd!
  autocmd BufWritePost $MYVIMRC,{plugins,mappings}.vim nested source $MYVIMRC
  autocmd BufWritePost plugins/* echo 'wat'
  autocmd BufReadPost $MYVIMRC call VimrcMappings()
augroup END

function! VimrcMappings()
  nnoremap <buffer><nowait> <leader>ps :call JumpToPluginSettings()<CR>
  nnoremap <buffer><nowait> <leader>pm :call JumpToMappings()<CR>
  nnoremap <buffer><nowait> <leader>pg :call GoToPluginUrl()<CR>
  nnoremap <buffer><nowait> <leader>py :call YankPluginUrl()<CR>
  nnoremap <buffer><nowait> <leader>pp :call PastePluginFromClipboard()<CR>
  nnoremap <buffer><nowait> <leader>pi :PlugInstall<CR>
  nnoremap <buffer><nowait> <leader>pu :PlugUpdate<CR>
  nnoremap <buffer><nowait> <leader>pc :PlugClean<CR>
endfunction

function! GetRef()
  let line = line('.')
  normal {jj
  let ref = matchlist(getline('.'), 'Ref: \(.*\)')[1]
  execute 'normal ' . line . 'G'
  return ref
endfunction

function! JumpToPluginSettings()
  silent execute 'edit ' s:VimrcPath('plugins/' . GetRef() . '.vim')
endfunction

function! JumpToMappings()
  let ref = matchlist(expand('%:t'), '\(.*\)\.')[1]
  silent execute 'edit ' s:VimrcPath('mappings.vim')
  if ref != GetRef()
    call search('Ref: ' . ref)
  endif
endfunction

function! YankPluginUrl()
  normal ^wyi'
  let @+ = 'https://www.github.com/' . @+
  return @+
endfunction

function! GoToPluginUrl()
  call YankPluginUrl()
  call system('chrome-cli open ' . @+)
endfunction

function! GetInstallablePluginFromClipboard()
  if match(@+, 'github.com') > -1
    return matchlist(@+, '\.com/\([^/]*/[^/]*\)')[1]
  elseif match(@+, 'Plug ') > -1
    return matchlist(@+, "'\\(.*\\)'")[1]
  endif
  return @+
endfunction

function! PastePluginFromClipboard()
  normal G
  call search("Plug \'.*\'", 'b')
  execute "normal oPlug " . substitute("'p'", 'p', GetInstallablePluginFromClipboard(), '')
endfunction


" ------------------------------------------------------------------------------
" # Shtuff
" ------------------------------------------------------------------------------

function! ShtuffStrategy(cmd)
  call system("shtuff into " . shellescape(g:shtuff_as) . " " . shellescape("clear;" . a:cmd))
endfunction

function! TestToggleStrategy()
  if exists("g:test#strategy")
    unlet g:test#strategy
    echo "Test Strategy: default"
  else
    let g:test#strategy = "shtuff"
    echo "Test Strategy: shtuff into test"
  endif
endfunction

command! TestToggleStrategy call TestToggleStrategy()

let g:shtuff_as = "test"
let g:test#custom_strategies = {'shtuff': function('ShtuffStrategy')}

if match(system('shtuff has test'), 'was found') > 0
  let g:test#strategy = "shtuff"
elseif exists('g:test#strategy')
  unlet g:test#strategy
endif


" ------------------------------------------------------------------------------
" # Experimenting
" ------------------------------------------------------------------------------

function! RecordGif()
  let g:fzf_layout = { 'down': '~55%' }
  :ALEDisable
endfunction
command! RecordGif silent! call RecordGif()

augroup goyo_events
  autocmd!
  autocmd User GoyoEnter nested call <SID>goyo_enter()
  autocmd User GoyoLeave nested call <SID>goyo_leave()
augroup END

let g:limelight_conceal_ctermfg = 'black'

if !exists("*s:goyo_enter")
  function! s:goyo_enter()
    nnoremap j gj
    nnoremap k gk
    Limelight
  endfunction
endif

if !exists("*s:goyo_leave")
  function! s:goyo_leave()
    nunmap j
    nunmap k
    Limelight!
    so $MYVIMRC
  endfunction
endif

if has("gui_running")
  set guioptions=
  set guifont=Menlo\ LG100
endif

" command! -bang -nargs=+ Methods
"   \ call fzf#vim#buffer_tags(<q-args>, { 'options': ['--nth', '..-2,-1', '--query', '^f$ '] })

" When using `dd` in the quickfix list, remove the item from the quickfix list.
" https://stackoverflow.com/questions/42905008/quickfix-list-how-to-add-and-remove-entries

function! RemoveQuickfixItem()
  let curqfidx = line('.') - 1
  let qfall = getqflist()
  call remove(qfall, curqfidx)
  call setqflist(qfall, 'r')
  execute curqfidx + 1 . "cfirst"
  copen
endfunction
command! RemoveQuickfixItem silent! call RemoveQuickfixItem()

function! OpenWritableSearchBufferFromQuickfix()
  WritableSearchFromQuickfix
  wincmd o
endfunction
command! OpenWritableSearchBufferFromQuickfix silent! call OpenWritableSearchBufferFromQuickfix()

augroup quickfix_mappings
  autocmd!
  autocmd FileType qf nnoremap <buffer> dd :RemoveQuickfixItem<CR>
  autocmd FileType qf nnoremap <buffer> p :.cc<CR><C-w>j
  autocmd FileType qf nnoremap <buffer> <Leader>w :OpenWritableSearchBufferFromQuickfix<CR>
augroup END

" Because :sav works, but doesn't save relative to the source's location, and doesn't open the duplicated file either.

function! DuplicateCurrentFile(path)
  let path = "%:h/" . a:path
  execute "saveas " . path
  execute "edit " . path
endfunction

command! -bar -nargs=1 Duplicate call DuplicateCurrentFile(<q-args>)

" Php import sorting.
" Look into php-cs-fixer and ale instead? :P

function! SortLinesByLength() range
  silent execute a:firstline . ',' . a:lastline . 'sort'
  silent execute a:firstline . ',' . a:lastline . 's/^\(.*\)$/\=strdisplaywidth(submatch(0))." ".submatch(0)/'
  silent execute a:firstline . ',' . a:lastline . 'sort n'
  silent execute a:firstline . ',' . a:lastline . 's/^\d\+\s//'
endfunction

function! PhpSortImports(...)
  normal gg
  call search('use .*;')
  let firstline = line('.')
  if firstline == 1
    echo 'No imports to sort.'
    return
  endif
  normal }k
  let lastline = line('.')
  if a:0 && a:1 == 'length'
    execute firstline . ',' . lastline . 'call SortLinesByLength()'
    echo 'Sorted imports by length.'
  else
    execute firstline . ',' . lastline . 'sort'
    echo 'Sorted imports alphabetically.'
  endif
endfunction

command! -bar PhpSortImports call PhpSortImports()
command! -bar PhpSortImportsByLength call PhpSortImports('length')

nmap <Leader>psi :PhpSortImports<CR>
nmap <Leader>psl :PhpSortImportsByLength<CR>

" Messing with CtrlSF

let g:ctrlsf_ackprg = '/usr/local/bin/ag'

let g:ctrlsf_auto_focus = {
    \ "at": "start"
    \ }

command! -n=* -comp=customlist,ctrlsf#comp#Completion CtrlSFSmart call ctrlsf#Search(agriculture#smart_quote_input(<q-args>))

nmap <Leader><Leader><Leader>/ :CtrlSFSmart<Space>


